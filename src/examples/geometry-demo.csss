#include "stdio.h"
#include "math.h"
#include "geometry-demo.h"
#include "../utils.h"
#include "../array.h"
#include "../vector.h"
#include "../matrix.h"
#include "../camera.h"
#include "../display.h"
#include "../clipping.h"
#include "../geometry.h"
#include "../triangle.h"
#include "../light.h"

#define MAX_TRIANGLES_PER_MESH 10000


static perspective_camera_t* camera = NULL;
static mesh_t* plane = NULL;
static mesh_t* sphere = NULL;
static mesh_t* box = NULL;
static mesh_t* ring = NULL;
static mesh_t* torus = NULL;
static mesh_t* efa = NULL;

void geometry_example_setup(void) {
	set_render_method(RENDER_TEXTURED);

	float aspectx = (float)get_viewport_width() / (float)get_viewport_height();
	float aspecty = (float)get_viewport_height() / (float)get_viewport_width();
	float fovy = 3.141592 / 3.0;
	float fovx = atan(tan(fovy / 2) * aspectx) * 2;
	float z_near = 1.0;
	float z_far = 100.0;

	vec3_t cam_position = { .x = 4, .y = 5, .z = -7 };
	vec3_t cam_target = { .x = 0, .y = 0, .z = 0 };
	camera = make_perspective_camera(fovy, aspecty, z_near, z_far, cam_position, cam_target);
	
	
	init_frustum_planes(fovx, fovy, z_near, z_far);

	plane = make_plane(3, 3, 3, 3);
	load_mesh_png_data(plane, "./assets/debug.png");
	plane->rotation.x = M_PI / 2;
	plane->translation.x = 2;
	plane->translation.z = 3;

	sphere = make_sphere(1, 10, 10, 0, M_PI * 2, 0, M_PI);
	load_mesh_png_data(sphere, "./assets/debug.png");
	sphere->translation.x = -2;
	sphere->translation.z = 3;

	box = make_box(1, 1, 1, 4, 4, 4);
	load_mesh_png_data(box, "./assets/debug.png");
	box->translation.x = 2;
	box->translation.z = 0;

	ring = make_ring(0.5, 1, 32, 10, 0, M_PI * 2);
	ring->rotation.x = M_PI / 2;
	load_mesh_png_data(ring, "./assets/debug.png");
	ring->translation.x = -2;
	ring->translation.z = 0;

	torus = make_torus(1, 0.4, 12, 48, M_PI * 2);
	load_mesh_png_data(torus, "./assets/debug.png");
	torus->translation.x = 2;
	torus->translation.z = -3;

	efa = load_mesh(
		"./assets/efa.obj",
		"./assets/efa.png",
		vec3_new(1, 1, 1),
		vec3_new(0, 0, 0),
		vec3_new(0, 0, 0)
	);
	efa->translation.x = -2;
	efa->translation.z = -3;
	efa->scale.x = 0.75;
	efa->scale.y = 0.75;
	efa->scale.z = 0.75;
}

void geometry_example_process_input(SDL_Event* event, int delta_time) {
	switch (event->type) {
		case SDL_MOUSEMOTION:
			if (event->motion.state & SDL_BUTTON_LMASK) {
				update_camera_on_drag(camera, event->motion.xrel, event->motion.yrel);
			}
			break;
		case SDL_MOUSEWHEEL:
			camera->distance += -event->wheel.preciseY * 0.01 * delta_time;
			update_camera_on_drag(camera, 0, 0);
			break;
	}
}

void geometry_example_update(int delta_time) {
	float delta_multiplier = 0.00075;
	box->rotation.x += delta_time * delta_multiplier;
	box->rotation.y += delta_time * delta_multiplier;
	box->rotation.z += delta_time * delta_multiplier;

	// plane->rotation.x += delta_time * delta_multiplier;
	sphere->rotation.y += delta_time * delta_multiplier;
	box->rotation.z -= delta_time * delta_multiplier;
	torus->rotation.y += delta_time * delta_multiplier;
	torus->rotation.z += delta_time * delta_multiplier;
	efa->rotation.y += delta_time * delta_multiplier;
}

void geometry_example_render(int delta_time) {
	for (int mesh_index = 0; mesh_index < get_meshes_count(); mesh_index++) {
		mesh_t* mesh = get_mesh(mesh_index);
		mesh_update_world_matrix(mesh);
		int num_faces = array_length(mesh->faces);

		num_triangles_to_render = 0;

		for (int i = 0; i < num_faces; i++) {
			face_t face = mesh->faces[i];
			vec3_t face_vertices[3];
			face_vertices[0] = mesh->vertices[face.a];
			face_vertices[1] = mesh->vertices[face.b];
			face_vertices[2] = mesh->vertices[face.c];
			vec4_t transformed_vertices[3];

			for (int j = 0; j < 3; j++) {
				vec4_t transformed_vertex = vec4_from_vec3(face_vertices[j]);
				transformed_vertices[j] = mat4_mul_vec4(mesh->world_matrix, transformed_vertex);
				transformed_vertices[j] = mat4_mul_vec4(camera->view_matrix, transformed_vertices[j]);
			}

			vec3_t vector_a = vec3_from_vec4(transformed_vertices[0]); /*   A   */
			vec3_t vector_b = vec3_from_vec4(transformed_vertices[1]); /*  / \  */
			vec3_t vector_c = vec3_from_vec4(transformed_vertices[2]); /* C---B */

			// Get the vector subtraction of B-A and C-a
			vec3_t vector_ab = vec3_sub(vector_b, vector_a);
			vec3_normalize(&vector_ab);
			vec3_t vector_ac = vec3_sub(vector_c, vector_a);
			vec3_normalize(&vector_ac);
			
			// Compute the face normal using cross product
			vec3_t vector_normal = vec3_cross(vector_ab, vector_ac);
			vec3_normalize(&vector_normal);

			// Find the vector between a point in the triangle and the camera origin
			// Our camera is always at origin (0 0 0) (camera space)
			vec3_t origin = { 0, 0, 0 };
			vec3_t camera_ray = vec3_sub(origin, vector_a);

			// Calculate how aligned the camera_ray is with the face normal using dot product
			float dot_normal_camera = vec3_dot(vector_normal, camera_ray);

			if (is_cull_backface()) {
				if (dot_normal_camera < 0) {
					continue;
				}
			}

			// Create a polygon from the original transformed triangle to be clipped
			polygon_t polygon = create_polygon_from_triangles(
				vec3_from_vec4(transformed_vertices[0]),
				vec3_from_vec4(transformed_vertices[1]),
				vec3_from_vec4(transformed_vertices[2]),
				face.a_uv,
				face.b_uv,
				face.c_uv
			);

			// Clips the polygon and returns a new polygon with potentially new vertices
			clip_polygon(&polygon);

			// Break the clipped polygon apart back to individual triangles
			triangle_t triangles_after_clipping[MAX_NUMBER_POLY_TRIANGLES];
			int num_triangles_after_clipping = 0;

			triangles_from_polygon(&polygon, triangles_after_clipping, &num_triangles_after_clipping);

			// Loops all the assembled triangles after clipping
			for (int t = 0; t < num_triangles_after_clipping; t++) {
				triangle_t triangle_after_clipping = triangles_after_clipping[t];

				vec4_t projected_points[3];

				for (int j = 0; j < 3; j++) {
					projected_points[j] = mat4_mul_vec4_project(camera->projection_matrix, triangle_after_clipping.points[j]);

					float half_window_width = get_viewport_width() / 2.0;
					float half_window_height = get_viewport_height() / 2.0;

					projected_points[j].x *= half_window_width;
					projected_points[j].y *= half_window_height;

					projected_points[j].y *= -1;
					projected_points[j].x += half_window_width;
					projected_points[j].y += half_window_height;
				}

				uint32_t triangle_color = face.color;
				triangle_t triangle_to_render = {
					.points = {
						{ projected_points[0].x, projected_points[0].y, projected_points[0].z, projected_points[0].w },
						{ projected_points[1].x, projected_points[1].y, projected_points[1].z, projected_points[1].w },
						{ projected_points[2].x, projected_points[2].y, projected_points[2].z, projected_points[2].w }
					},
					.color = triangle_color,
					.tex_coords = {
						{ triangle_after_clipping.tex_coords[0].u, triangle_after_clipping.tex_coords[0].v },
						{ triangle_after_clipping.tex_coords[1].u, triangle_after_clipping.tex_coords[1].v },
						{ triangle_after_clipping.tex_coords[2].u, triangle_after_clipping.tex_coords[2].v },
					},
					.texture = mesh->texture
				};

				if (num_triangles_to_render < MAX_TRIANGLES_PER_MESH) {
					triangles_to_render[num_triangles_to_render++] = triangle_to_render;
				}
			}
		}

		for (int i = 0; i < num_triangles_to_render; i++) {
			triangle_t triangle = triangles_to_render[i];
			if (should_render_filled_triangles()) {
			draw_filled_triangle(
				triangle.points[0].x, triangle.points[0].y, triangle.points[0].z, triangle.points[0].w,
				triangle.points[1].x, triangle.points[1].y, triangle.points[1].z, triangle.points[1].w,
				triangle.points[2].x, triangle.points[2].y, triangle.points[2].z, triangle.points[2].w,
				triangle.color,
				get_screen_color_buffer(),
				get_screen_depth_buffer()
			);
		}

		if (should_render_textured_triangles()) {
			if (triangle.texture == NULL) {
				draw_triangle(
					triangle.points[0].x, triangle.points[0].y,
					triangle.points[1].x, triangle.points[1].y,
					triangle.points[2].x, triangle.points[2].y,
					LINE_DEBUG_COLOR,
					get_screen_color_buffer()
				);
			} else {
				draw_textured_triangle(
					triangle.points[0].x, triangle.points[0].y, triangle.points[0].z, triangle.points[0].w, triangle.tex_coords[0].u, triangle.tex_coords[0].v,
					triangle.points[1].x, triangle.points[1].y, triangle.points[1].z, triangle.points[1].w, triangle.tex_coords[1].u, triangle.tex_coords[1].v,
					triangle.points[2].x, triangle.points[2].y, triangle.points[2].z, triangle.points[2].w, triangle.tex_coords[2].u, triangle.tex_coords[2].v,
					triangle.texture,
					get_screen_color_buffer(),
					get_screen_depth_buffer(),
					NULL
				);
			}
		}

		if (should_render_wireframe()) {
			draw_triangle(
				triangle.points[0].x, triangle.points[0].y,
				triangle.points[1].x, triangle.points[1].y,
				triangle.points[2].x, triangle.points[2].y,
				LINE_DEBUG_COLOR,
				get_screen_color_buffer()
			);
		}

		if (should_render_vertex()) {
			for (int j = 0; j < 3; j++) {
				int size = 10;
				draw_rect(
					triangle.points[j].x - size / 2, triangle.points[j].y - size / 2,
					size, size,
					LINE_DEBUG_COLOR
				);
			}
		}
		}
	}
}

void geometry_example_free_resources(void) {
	dispose_meshes();
}